"""Program utils for working with the assembly files"""

__author__ = "Aaron Gonzales, Andres Ruiz"
__license__ = "Apache"
__email__ = "agonzales@cs.unm.edu"


import sys
import pymongo as pm
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import numpy as np

def open_asm(filename, path='/malware/data/all_data/train/'):
    """Reads all the lines in an assembly file correctly.
    Args:
        filename (str): the hash name of the file. e.g., "haa4945azkda09", no
                        path or extension
        path (str): the path of the file. Defaults to the sudo path
        returns:
            a list of all the decoded strings in bytecode format
    """
    datapath = path + filename + '.asm'
    with open(datapath, 'rb') as f:
        asm = [to_utf(line) for line in f.readlines()]
        return asm


def to_utf(line):
    """Converts a bytecode string to unicode. Ignores lines that have unicode
    decode errors.
    Args:
        line (string) a single line in the file
    Returns:
        a single line that's been cleaned
    """
    utf_line = ''
    try:
        utf_line = str(line, 'utf8')
        return utf_line
    except UnicodeDecodeError as u:
        print(u)
        return None


def get_mongodb(db_address="64.106.46.105",
                username='query', password='malware_challenge'):
    """
    Returns the mongodb root database you specify from mongo
    Args:
        db_address (str): url for the machine on which the mongo instance
                    lives; defaults to the dept vm. passing 'andres' will go to
                    andres' machines
        username (string): username for mongo
        Password (string): default to the password
        collection ('string'): the collection you want.
    """
    if db_address == 'andres':
        db_address="afruizc-office.cs.unm.edu",

    mg = pm.MongoClient(db_address)
    if not mg.malware.authenticate(username, password):
        sys.stderr.write("Authentication error. Terminating...")
        sys.stderr.flush()
    # return the database
    return mg.malware

def get_inst(asm_file, asm_instr):
    """Gets the sequence of instructions in an assembly file
    Args:
        asm_file (list): The file's line list
        asm_inst (list): the list of common assembly instructions
    Returns:
        flat list of instructions
    """
    words = [line.split() for line in asm_file if line is not None]
    return [word for line in words for word in line if word in asm_instr]


def asm_seq_info(instr_seq):
    """Returns a dictionary of aggregated counts on the
        assembly instruction sequence"""
    return {'seq': instr_seq,
            'num_instr': len(instr_seq),
            'uniq_instr': list(set(instr_seq)),
            'num_uniq_instr': len(set(instr_seq))
            }

def plot_confusion_matrix(cm, title='Confusion matrix', normalized=True,
                            cmap=plt.cm.Oranges, save_file=""):
    """
    Displays the confussion matrix indicated by `cm`. If argument
    `normalized` is Ture, then the matrix is normalized. Optionally
    the image can be saved to a file

    Arguments:
    ----------
    `cm`: The confusion matrix to be displayed.
    `title`: The title for the window.
    `normalized`: If True, normalizes the matrix before showing it.
    `cmap`: Colormap to use.
    `save_file`: If string different than empty, the resulting image is
    stored in such file.
    """
    if normalized:
        cm = cm.astype('float') / cm.sum(axis=1)[:, np.newaxis]
    plt.imshow(cm, interpolation='nearest', cmap=cmap)
    plt.title(title)
    plt.colorbar()
    plt.tight_layout()
    plt.ylabel('True label')
    plt.xlabel('Predicted label')

    if save_file:
        plt.savefig(save_file)

    return cm


def _predict(X, model, create_submission=False, filename='submission.txt'):
    """
    Predicts a set of 9 probabilities per malware sample, that
    correspond to the 9 malware classes. If `create_submission`
    is True, then a text file named `filename` is created for
    submission into Kaggle.

    Arguments:
    `X`: The data in which predictions will be made.
    `create_submission`: Indicates whether a submission file should
    be created or not.
    `filename`: The file that will contain the submission.
    """
    predicted_prob = model.predict_proba(X)
    if create_submission:
        to_print = np.column_stack((np.array(self.test['names']),
                                    predicted_prob))
        np.savetxt(filename, to_print, header=','.join(['"id"'] + \
                            ['"Prediction%d"' % x for x in range(1, 10)]), \
                               fmt='%s', delimiter=',')
    return predicted_prob
